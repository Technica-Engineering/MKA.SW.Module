/*******************************************************************************
*
* MKA daemon.
* SPDX-FileCopyrightText: 2022 Technica Engineering GmbH <macsec@technica-engineering.de>
* SPDX-License-Identifier: GPL-2.0-or-later
* file: test-aes-kdf.cpp
*
* Â© 2022 Technica Engineering GmbH.
*
* This program is free software: you can redistribute it and/or modify it under
* the terms of the GNU General Public License as published by the Free Software
* Foundation, either version 2 of the License, or (at your option) any later version.
*
* This program is distributed in the hope that it will be useful, but WITHOUT
* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License along with
* this program. If not, see https://www.gnu.org/licenses/
*
*******************************************************************************/

#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include <stdint.h>
#include "mka_private.h"
#include "ut_helpers.h"

extern void print_hex(u8 *hex, int len);

TEST(key_derivation, KDF_ANNEX_G_1_1)
{
    const uint8_t key[] = {
        0x1a, 0xb9, 0x02, 0x4f, 0xa0, 0x4a, 0x03, 0xfe,
        0xb9, 0x02, 0x4f, 0xa0, 0x4a, 0x03, 0xfe, 0x11
    };
    const uint8_t label[] = {
        0x48, 0x49, 0x20, 0x54, 0x48, 0x45, 0x52, 0x45
    };
    const uint8_t context[] = {
        0x01U, 0x02U, 0x01U, 0x04U
    };

    const uint32_t len = 0x0080U;
    uint8_t output[len/8];
        
    bool const result = ieee8021x_aes_kdf(
        /* kdk          */  key,
        /* kdk_len      */  sizeof(key),
        /* label        */  label,
        /* label_len    */  sizeof(label),
        /* context      */  context,
        /* context len  */  sizeof(context),
        /* ret_bits     */  len/8,
        /* ret          */  output
    );

    ASSERT_EQ(true, result) << "ieee8021x_aes_kdfes_kdf function failed";

    ASSERT_THAT(output, MemoryWith<uint8_t>({
        0xb5, 0x7a, 0x0b, 0x05, 0xf4, 0x3e, 0x96, 0x00,
        0xc3, 0xc4, 0xd1, 0x5c, 0x1e, 0x3c, 0x26, 0xe8
    })) << "ieee8021x_aes_kdf output is incorrect";
}

TEST(key_derivation, KDF_ANNEX_G_1_2)
{
    const uint8_t key[] = {
        0x39, 0x46, 0xec, 0x36, 0xf5, 0x90, 0x17, 0xf1,
        0x26, 0x7e, 0x91, 0x4a, 0xbe, 0xd2, 0xdb, 0xf6,
        0x63, 0x3f, 0x52, 0xae, 0x7e, 0x20, 0x30, 0x9d,
        0x3e, 0xef, 0xdd, 0xa4, 0x07, 0x3a, 0xdf, 0xad

    };
    const uint8_t label[] = {
        0x48, 0x49, 0x20, 0x54, 0x48, 0x45, 0x52, 0x45
        
    };
    const uint8_t context[] = {
        0x01U, 0x02U, 0x01U, 0x04U
    };

    const uint32_t len = 0x0100U;
    uint8_t output[len/8];
        
    bool const result = ieee8021x_aes_kdf(
        /* kdk          */  key,
        /* kdk_len      */  sizeof(key),
        /* label        */  label,
        /* label_len    */  sizeof(label),
        /* context      */  context,
        /* context len  */  sizeof(context),
        /* ret_len      */  len/8,
        /* ret          */  output
    );

    ASSERT_EQ(true, result) << "ieee8021x_aes_kdfes_kdf function failed";

    ASSERT_THAT(output, MemoryWith<uint8_t>({
        0x0e, 0xfd, 0x01, 0xe5, 0xb0, 0x3a, 0x09, 0x51,
        0xa6, 0xdf, 0x9b, 0xbf, 0xfe, 0x41, 0x90, 0x16,
        0xee, 0x40, 0xfd, 0xbf, 0xc3, 0x33, 0x5e, 0xbf,
        0x92, 0xea, 0x03, 0x80, 0x22, 0x14, 0xa3, 0x07
    })) << "ieee8021x_aes_kdf output is incorrect";
}

TEST(key_derivation, KEK_ANNEX_G_4_1)
{
    const t_MKA_key cak = {
        {   0x13, 0x5b, 0xd7, 0x58, 0xb0, 0xee, 0x5c, 0x11,
            0xc5, 0x5f, 0xf6, 0xab, 0x19, 0xfd, 0xb1, 0x99  },
        16U
    };
    const t_MKA_ckn ckn = {
        {   0x96, 0x43, 0x7a, 0x93, 0xcc, 0xf1, 0x0d, 0x9d,
            0xfe, 0x34, 0x78, 0x46, 0xcc, 0xe5, 0x2c, 0x7d  },
        16U
    };
    t_MKA_key kek;
        
    bool const result = MKA_DeriveKEK(&cak, &ckn, MKA_KEY_128BIT, &kek);

    ASSERT_EQ(true, result) << "MKA_DeriveKEK function failed";

    ASSERT_THAT(kek.length, Eq(MKA_KEY_128BIT));
    ASSERT_THAT(kek.key, MemoryWith<uint8_t>({
        0x8f, 0x5a, 0x38, 0x4c, 0x15, 0xd6, 0xae, 0x93,
        0x02, 0xb4, 0x62, 0xe3, 0x63, 0xd0, 0x3c, 0xa6
    })) << "MKA_DeriveKEK output is incorrect";
}

TEST(key_derivation, KEK_ANNEX_G_4_2)
{
    const t_MKA_key cak = {
        {   0xa2, 0x9e, 0xfd, 0xb6, 0x3d, 0x6f, 0xba, 0x73,
            0xc6, 0x5d, 0xaa, 0xb2, 0x29, 0x53, 0x40, 0xa8,
            0x37, 0xa8, 0x88, 0x6e, 0x94, 0xa9, 0x05, 0xb5,
            0xc9, 0xc7, 0xef, 0x1d, 0x9d, 0xbb, 0x29, 0x7e  },
        32U
    };
    const t_MKA_ckn ckn = {
        {   0x78, 0x88, 0xf5, 0xd4, 0x8b, 0xa8, 0xb2, 0x4e,
            0x96, 0xbb, 0x95, 0xbd, 0x8c, 0x73, 0x04, 0xec  },
        16U
    };
    t_MKA_key kek;
        
    bool const result = MKA_DeriveKEK(&cak, &ckn, MKA_KEY_256BIT, &kek);

    ASSERT_EQ(true, result) << "MKA_DeriveKEK function failed";

    ASSERT_THAT(kek.length, Eq(MKA_KEY_256BIT));
    ASSERT_THAT(kek.key, MemoryWith<uint8_t>({
            0x71, 0x34, 0x0e, 0x45, 0x4c, 0x84, 0xa1, 0x23,
            0x2a, 0xa7, 0x97, 0x7d, 0x5e, 0xd8, 0x6f, 0x78,
            0xf2, 0x50, 0xf3, 0xf9, 0xd5, 0x35, 0x84, 0xb9,
            0x33, 0x7f, 0xf0, 0xc6, 0xdf, 0xdc, 0x9f, 0x96
    })) << "ieee8021x_aes_kdf output is incorrect";
}

TEST(key_derivation, ICK_ANNEX_G_5_1)
{
    const t_MKA_key cak = {
        {   0x13, 0x5b, 0xd7, 0x58, 0xb0, 0xee, 0x5c, 0x11,
            0xc5, 0x5f, 0xf6, 0xab, 0x19, 0xfd, 0xb1, 0x99  },
        16U
    };
    const t_MKA_ckn ckn = {
        {   0x96, 0x43, 0x7a, 0x93, 0xcc, 0xf1, 0x0d, 0x9d,
            0xfe, 0x34, 0x78, 0x46, 0xcc, 0xe5, 0x2c, 0x7d  },
        16U
    };
    t_MKA_key ick;
        
    bool const result = MKA_DeriveICK(MKA_ALGORITHM_AGILITY, &cak, &ckn, MKA_KEY_128BIT, &ick);

    ASSERT_EQ(true, result) << "MKA_DeriveICK function failed";

    ASSERT_THAT(ick.length, Eq(MKA_KEY_128BIT));
    ASSERT_THAT(ick.key, MemoryWith<uint8_t>({
            0x8f, 0x1c, 0x5c, 0xb1, 0xc8, 0xed, 0x2e, 0x5f,
            0x04, 0x79, 0x06, 0xe0, 0x47, 0x3a, 0xad, 0x4d
    })) << "MKA_DeriveICK output is incorrect";
}

TEST(key_derivation, ICK_ANNEX_G_5_2)
{
    const t_MKA_key cak = {
        {   0xa2, 0x9e, 0xfd, 0xb6, 0x3d, 0x6f, 0xba, 0x73,
            0xc6, 0x5d, 0xaa, 0xb2, 0x29, 0x53, 0x40, 0xa8,
            0x37, 0xa8, 0x88, 0x6e, 0x94, 0xa9, 0x05, 0xb5,
            0xc9, 0xc7, 0xef, 0x1d, 0x9d, 0xbb, 0x29, 0x7e  },
        32U
    };
    const t_MKA_ckn ckn = {
        {   0x78, 0x88, 0xf5, 0xd4, 0x8b, 0xa8, 0xb2, 0x4e,
            0x96, 0xbb, 0x95, 0xbd, 0x8c, 0x73, 0x04, 0xec  },
        16U
    };
    t_MKA_key ick;
        
    bool const result = MKA_DeriveICK(MKA_ALGORITHM_AGILITY, &cak, &ckn, MKA_KEY_256BIT, &ick);

    ASSERT_EQ(true, result) << "MKA_DeriveICK function failed";

    ASSERT_THAT(ick.length, Eq(MKA_KEY_256BIT));
    ASSERT_THAT(ick.key, MemoryWith<uint8_t>({
            0x98, 0xb8, 0x54, 0x4d, 0x73, 0x90, 0xa4, 0x1e,
            0x50, 0xef, 0x72, 0xe2, 0x5b, 0x4a, 0x03, 0x65,
            0x23, 0xc9, 0x19, 0xe8, 0x12, 0x91, 0x88, 0x71,
            0x94, 0x9b, 0x48, 0x12, 0x3e, 0xab, 0x52, 0x6e
    })) << "MKA_DeriveICK output is incorrect";
}

TEST(key_derivation, SAK_ANNEX_G_6_1)
{
    const t_MKA_key cak = {
        {   0x13, 0x5b, 0xd7, 0x58, 0xb0, 0xee, 0x5c, 0x11,
            0xc5, 0x5f, 0xf6, 0xab, 0x19, 0xfd, 0xb1, 0x99  },
        16U
    };
    const uint8_t ks_nonce[] = {
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10
    };
    const uint8_t mi_list[24U] = {
            0xcd, 0x42, 0x1c, 0xf8, 0x6b, 0xa4, 0x57, 0x93,
            0x86, 0x57, 0x67, 0x5b, 0x01, 0x02, 0x03, 0x04,
            0x05, 0x06, 0x07, 0x08, 0x0d, 0x1f, 0x36, 0xcf
    };

    t_MKA_key sak;
        
    bool const result = MKA_DeriveSAK(
        /* cak          */  &cak,
        /* ks_nonce     */  ks_nonce,
        /* mi_local     */  &mi_list[0U],
        /* mi_peer      */  &mi_list[12U],
        /* kn           */  0x00000001U,
        /* out_len      */  MKA_KEY_128BIT,
        /* sak          */  &sak
    );

    ASSERT_EQ(true, result) << "MKA_DeriveSAK function failed";

    ASSERT_THAT(sak.length, Eq(MKA_KEY_128BIT));
    ASSERT_THAT(sak.key, MemoryWith<uint8_t>({
            0x04, 0x52, 0x05, 0x92, 0x58, 0x31, 0xae, 0x59,
            0xc1, 0x45, 0x50, 0xed, 0x59, 0xcc, 0x00, 0x3d
    })) << "MKA_DeriveSAK output is incorrect";
}

TEST(key_derivation, SAK_ANNEX_G_6_2)
{
    const t_MKA_key cak = {
        {   0xa2, 0x9e, 0xfd, 0xb6, 0x3d, 0x6f, 0xba, 0x73,
            0xc6, 0x5d, 0xaa, 0xb2, 0x29, 0x53, 0x40, 0xa8,
            0x37, 0xa8, 0x88, 0x6e, 0x94, 0xa9, 0x05, 0xb5,
            0xc9, 0xc7, 0xef, 0x1d, 0x9d, 0xbb, 0x29, 0x7e  },
        32U
    };
    const uint8_t ks_nonce[] = {
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10,
            0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,
            0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x00
    };
    const uint8_t mi_list[24U] = {
            0xcd, 0x42, 0x1c, 0xf8, 0x6b, 0xa4, 0x57, 0x93,
            0x86, 0x57, 0x67, 0x5b, 0x01, 0x02, 0x03, 0x04,
            0x05, 0x06, 0x07, 0x08, 0x0d, 0x1f, 0x36, 0xcf
    };

    t_MKA_key sak;
        
    bool const result = MKA_DeriveSAK(
        /* cak          */  &cak,
        /* ks_nonce     */  ks_nonce,
        /* mi_local     */  &mi_list[0U],
        /* mi_peer      */  &mi_list[12U],
        /* kn           */  0x00000001U,
        /* out_len      */  MKA_KEY_256BIT,
        /* sak          */  &sak
    );

    ASSERT_EQ(true, result) << "MKA_DeriveSAK function failed";

    ASSERT_THAT(sak.length, Eq(MKA_KEY_256BIT));
    ASSERT_THAT(sak.key, MemoryWith<uint8_t>({
            0xbb, 0x69, 0x25, 0x68, 0xb2, 0x87, 0x48, 0x4a,
            0x5f, 0x3f, 0x47, 0x93, 0xb0, 0x97, 0x32, 0x27,
            0x0d, 0x13, 0xdd, 0x81, 0x83, 0x73, 0xc1, 0x5b,
            0x3f, 0x27, 0x93, 0xfd, 0xc1, 0x94, 0x8a, 0x37
    })) << "MKA_DeriveSAK output is incorrect";
}
